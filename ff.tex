%!TEX root = main.tex

\section{Preliminaries}\label{sec-defs}


We let $\emptystring$ denote the empty string. If $Z$ is a string then $|Z|$ denotes its length and $Z[1..i]$ denotes bits $1$ through $i$ of $Z$. If $\setX$ is a finite set, we let $x \getsr \setX$ denote picking an element of~$\setX$ uniformly at random and assigning it to $x$.
Algorithms may be randomized unless otherwise indicated. Running time is worst case.
If~$A$ is an algorithm, we let $y \gets A(x_1,\ldots;r)$ denote running~$A$ with random coins $r$ on inputs $x_1,\ldots$ and assigning the output to $y$.
We let $y \getsr A(x_1,\ldots)$ be the result of picking $r$ at random and letting $y \gets A(x_1,\ldots;r)$. We let $[A(x_1,\ldots)]$ denote the set of all possible outputs of $A$ when invoked with inputs $x_1,\ldots$.

We use the code-based game-playing framework of BR~\cite{EC:BelRog06}. (See \figref{fig-ind} for an example.) By $\Pr[\gameG]$ we denote the probability that the execution of game $\gameG$ results in the game returning $\true$. In games, integer variables, set variables and boolean variables are assumed initialized, respectively, to $0$, the empty set, and $\false$.

A family of functions $\FF \Colon \KEYS{\FF} \cross \DOM{\FF}\to \RNG{\FF}$ is a two-argument function that takes a key $K$ in the key space $\KEYS{\FF}$, an input $x$ in the domain $\DOM{\FF}$ and returns an output $\FF(K,x)$ in the range $\RNG{\FF}$. We say $\FF$ has key length $\KLength{\FF}$ if
$\KEYS{\FF}=\bits^{\KLength{\FF}}$; output length $\OLength{\FF}$ if $\RNG{\FF}=\bits^{\OLength{\FF}}$; and input length $\ILength{\FF}$ if $\DOM{\FF}=\bits^{\ILength{\FF}}$.

We say that $\FF\Colon \bits^{\KLength{\FF}}\cross \bits^{\ILength{\FF}}\to\bits^{\OLength{\FF}}$ is a \emph{block cipher} if $\ILength{\FF}=\OLength{\FF}$ and $\FF(K,\cdot) \Colon \bits^{\ILength{\FF}}\to\bits^{\OLength{\FF}}$ is a permutation for each $K$ in $\bits^{\KLength{\FF}}$. We denote by $\FF^{-1}(K,\cdot)$ the inverse of $\FF(K,\cdot)$.






\section{Multi-User Security of Symmetric Encryption}\label{sec-mu-defs}

We consider symmetric encryption in a multi-user setting. We give two definitions of security. The first, an indistinguishability-style definition, extends Rogaway's single-user definition~\cite{CCS:Rogaway02} to the multi-user setting, and represents a very strong requirement. We also define security against key recovery, representing the goal the attacker would most like to achieve and the most common target of cryptanalysis. We will see that the security bounds for these notions can differ. Since our analyses will be in the ideal-cipher model, the definitions are given directly in that model.


\heading{Syntax.} A symmetric encryption scheme $\seScheme$ specifies a 
deterministic encryption algorithm $\seEnc  \allowbreak  \Colon  \allowbreak  \bits^{\sekl}  \allowbreak \cross \allowbreak   \seNS  \allowbreak  \cross  \allowbreak  \bits^*  \allowbreak \cross \bits^* \to \bits^*$ that takes a key $\nkey \in \bits^{\sekl}$, a nonce $\iv \in \seNS$, a message $\msg\in\bits^*$ and a header $\header\in\bits^*$ to return a ciphertext 
$
  \ciph \gets \allowbreak \seEnc(\nkey,\allowbreak \iv,\allowbreak \msg,\header) \allowbreak \in \allowbreak \bits^{\SEcl(|\msg|)}
$.
Here $\sekl\in\N$ is the key length of the scheme, $\seNS$ is the nonce space and $\SEcl\Colon\N\to\N$ is the ciphertext length function.  We view the key length $\seckl$ and block length $\secbl$ of the cipher as further parameters of $\seScheme$ itself. Also specified is a deterministic decryption algorithm $\seDec \Colon \bits^{\sekl}\cross \seNS \cross \bits^* \cross \bits^* \to \bits^*\cup\{\bot\}$  that takes $\nkey,\iv,\ciph,\header$ and returns $\msg \gets \seDec(\nkey,\iv,\ciph,\header) \in \bits^*\cup\{\bot\}$. Correctness requires that $\seDec(\nkey,\iv,\seEnc(\nkey,\iv,\msg,\header),\header) = \msg$ for all $\msg,\header \in \bits^*$, all $\iv\in\seNS$ and all $\nkey \in\bits^{\sekl}$.

\begin{figure} [t]
\twoCols{0.45}{0.45}{
\gameName{$\gAE{\seScheme}(\advA)$} 
% $U,V\gets\emptyset$ covered by conventions
$b \getsr \bits$ ;
$b' \getsr \advA^{\NewO,\EncO,\VfO}$\\
Return $(b' = b)$ \medskip

\underline{$\NewO()$} \\[2pt]
$v\gets v+1$ ; $\nkey[v] \getsr\bits^{\sekl}$ \medskip

\underline{$\EncO(i,\iv,\msg,\header)$}\\[2pt]
If not ($1\leq i\leq v$) then return $\bot$ \\
If ($(i,\iv)\in V$) then return $\bot$ \\
$\ciph_1\gets \seEnc(\nkey[i],\iv,\msg,\header)$\\
$\ciph_0\getsr\bits^{\SEcl(|\msg|)}$ \\
$V\gets V\cup\{(v,\iv)\}$ ; $W \gets W \cup \{ (i,\iv,\ciph_b,\header) \}$ \\
Return $\ciph_b$
}
{
\underline{$\VfO(i,\iv,\ciph,\header)$}\\[2pt]
If not ($1\leq i\leq v$) then return $\bot$ \\
If ($(i,\iv,\ciph,\header) \in W$) then return $\true$ \\ 
If ($b=0$) then return $\false$ \\
$\msg \gets \seDec(\nkey[i],\iv,\ciph,\header)$ \\
Return ($\msg\neq\bot)$ \medskip


}
\vspace{-2ex}
\caption{Game defining multi-user indistinguishability security of symmetric encryption scheme $\seScheme$ in the ideal-cipher model.}
\label{fig-ind}
\hrulefill
\end{figure}


\heading{Indistinguishability Security.}
We extend Rogaway's definition of  indistinguishability security for authenticated encryption~\cite{CCS:Rogaway02}, which is in the single-user setting, to the multi-user setting. The formalization is based on game $\gAE{\seScheme}(\advA)$ of \figref{fig-ind}, associated to encryption scheme $\seScheme$ and adversary $\advA$. The game initially samples a random challenge bit $b$, with $b=1$ indicating it is in ``real'' mode and $b=0$ that it is in ``ideal" mode. As per our conventions noted in \secref{sec-defs},  the sets $V,W$ are assumed initialized to the empty set, and the integer $v$ is assumed initialized to $0$. Now the adversary $\advA$ has access to an oracle $\NewO$ that creates new user instances. $\advA$ also has access to an encryption oracle $\EncO$ that takes a user instance identifier $i$, a nonce $\iv \in \seNS$, a message $\msg$, and a header $\header$. The oracle either returns a uniformly random bit string of length $\SEcl$ that depends only on the length of $\msg$ (for $b=0$), or an encryption under $\seEnc$ using the key of user $i$  (for $b=1$). The oracle checks that $\advA$ does not re-use nonces for a user instance, and that it is invoked only for user instances that exist. Analogously, there is a verification oracle $\VfO$ that takes user instance $i$, nonce $\iv \in \seNS$, ciphertext $\ciph$, and header $\header$. Oracle $\VfO$ always accepts ciphertexts generated by $\EncO$ for the same  $i$, $\iv$, and $\header$, rejects all other ciphertexts for $b=0$, and uses the decryption algorithm $\seDec$ to check the validity of the ciphertext for $b=1$.  As a last step, the adversary outputs a bit $b'$ that can be viewed as a guess for $b$.  The advantage of adversary $\advA$ in breaking the mu-ind security of   $\seScheme$ is defined as $\aeAdv{\seScheme}{\advA} = 2\Pr[\gAE{\seScheme}(\advA)]- 1$.





One can further strengthen the security of the above ind definition by considering \emph{nonce-misuse resistance} as defined by Rogaway and Shrimpton~\cite{EC:RogShr06}. This requires changing the condition $(i,\iv)\in U$ in oracle $\EncO$ to only prevent queries where nonce \emph{and} message (or even nonce, message, and header) are repeated. 

Rogaway's definition of indistinguishability security for authenticated encryption (in the su setting)~\cite{CCS:Rogaway02} gives the adversary a decryption oracle, while we give it a verification oracle. The latter is simpler and our definition can be shown equivalent to one with a decryption oracle by the technique of BN~\cite{AC:BelNam00}.

%Note, maybe discuss EC:HoaKroRog15 here as well

%In the security statements, we generally use the following parameters: $\numu$ queries to $\NewO$, $\nume$ queries to $\EncO$, $\numv$ queries to $\VfO$, and $\numc$ queries each to either $\EvalO$ or $\InvO$.

\begin{figure} [t]
\twoCols{0.45}{0.45}{
\gameName{$\gKR{\seScheme}(\advA)$} 
% $U\gets\emptyset$ ; covered by conventions
$\bar\nkey \getsr \advA^{\NewO,\EncO,\VfO}$\\
Return $(\bar\nkey \in \{\nkey[1],\dots,\nkey[v]\})$ \medskip

\underline{$\NewO()$} \\[2pt]
$v\gets v+1$ ; $\nkey[v] \getsr\bits^{\sekl}$ \medskip

\underline{$\EncO(i,\iv,\msg,\header)$}\\[2pt]
If not ($1\leq i\leq v$) then return $\bot$ \\
If ($(i,\iv)\in V$) then return $\bot$ \\
$\ciph\gets \seEnc(\nkey[i],\iv,\msg,\header)$\\
$V\gets V\cup\{(i,\iv)\}$ \\
Return $\ciph$
}
{
\underline{$\VfO(i,\iv,\ciph,\header)$}\\[2pt]
If not ($1\leq i\leq v$) then return $\bot$ \\
$\msg \gets \seDec(\nkey[i],\iv,\ciph,\header)$ \\
Return ($\msg\neq\bot)$ \medskip
}
\vspace{-2ex}
\caption{Game defining multi-user key-recovery security of symmetric encryption scheme $\seScheme$.}
\label{fig-kr}
\hrulefill
\end{figure}



\heading{Key-Recovery Security.} The qualitatively weaker requirement of key-recovery security can sometimes be established with better bounds than ind, which is of practical importance since violating key recovery is much more damaging that violating ind. The formalization is based on game $\gKR{\seScheme}(\advA)$ of \figref{fig-kr}, associated to encryption scheme $\seScheme$ and adversary $\advA$.  The goal of the adversary $\advA$ is simply to output the key of any honest user. It again has access to oracles $\NewO$, $\EncO$, $\VfO$. Oracles $\EncO$ and $\VfO$ are defined to always return the values as determined by the scheme $\seScheme$. Adversary $\advA$ wins if it outputs any one of the keys that was generated using the $\NewO$ oracle. The advantage of $\advA$ in breaking the mu-kr security of $\seScheme$ is defined as $
	\krAdv{\seScheme}{\advA} \ = \ \Pr[\gKR{\seScheme}(\advA)]$.

